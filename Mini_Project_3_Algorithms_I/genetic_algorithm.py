import os  # For interfacing with operating system
import datetime  # For setting start and end dates
import pandas as pd  # for itnerfacing with DataFrames
import numpy as np  # For genetic array
import pandas_datareader.data as web  # Used for reading data from Google Finance
import random  # For selecting random Genes for Crossover
from sklearn import linear_model


def get_data_from_google(ticker, start_date, end_date):
    """
    This function takes a ticker, a start date and an end date, and returns a pandas DataFrame
    which contains the stock prices for the ticker, from start date to end date

    :param ticker: The ticker symbol for the stock
    :param start_date: The start date for fetching EoD Data from Google Finance
    :param end_date: The end date for fetching EoD Data from Google Finance

    :return: pd.DataFrame()
    """
    return web.DataReader(ticker, 'google', start_date, end_date)


def generate_population(minimum_value, maximum_value, population_size):
    """
    :param minimum_value: The minimum value in the an ndarray
    :param maximum_value: The maximum value in the ndarray
    :param population_size: The size of the population

    :return: Numpy ndarray
    """
    # Note: np.random.uniform is [low,high), that is, include low, excluding high.
    return np.random.uniform(minimum_value, maximum_value, population_size)


def process_population(observed_values, population, with_mutation=False):
    """
    This function accepts a population, which is nothing but conditions,
    and the close price of a stock (observed known values). And for each price
    that satisfies the conditions in populations, generates, collects and returns y's.

    :param observed_values: The observed values, or the known price, known as xbar
    :param population: The population, that is, a set of conditions, also known as C

    :return: Dictionary. A collection of y's that satisfy the conditions generated by c
    """
    # Initialize a dictionary of y's
    collection_of_y = dict()

    # A list to append the solutions to
    solution = list()

    # For every individual in population
    for index, individual in enumerate(population):
        # For every price in the observed_values, try and match the conditions
        for i in range(1, len(observed_values) - 1):
            # If mutation is True, then mutate the genes and send the output
            # mutation means bumping up the values individual's genes witha + or - 10
            if with_mutation:
                random_bump1 = random.random() * 10
                random_bump2 = random.random() * 10
                if observed_values[i-1] >= individual[0] and \
                        (observed_values[i] >= individual[1] + random_bump1 or observed_values[i] <= individual[2]) and \
                        (observed_values[i+1] >= individual[3] or observed_values[i+1] <= individual[4] + random_bump2):
                    solution.append(observed_values[i])
            else:
                if observed_values[i-1] >= individual[0] and \
                        (observed_values[i] >= individual[1] or observed_values[i] <= individual[2]) and \
                        (observed_values[i+1] >= individual[3] or observed_values[i+1] <= individual[4]):
                    solution.append(observed_values[i])
            collection_of_y[index] = solution
    # Blank out solution list
        solution = []
    return collection_of_y


def calculate_fitness(processed_population, close_price, alpha):
    """
    This function calculates the fitness of the population

    :param processed_population: The processed population
    :param close_price: The close prices
    :param alpha: The alpha

    :return: Dictionary containing the fitness of each of the population
    """
    # For every individal in population
    # Create an empty dictionary to hold the solution
    solution = dict()
    # Calculate the sigma of all the closed prices
    sigma0 = np.std(close_price)
    for key, value in processed_population.items():
        sigma = np.std(value)
        nc = len(value)
        fit = -np.log2(sigma/sigma0) - alpha/nc
        solution[key] = fit

    return solution


def main(improvement=False):
    """
    This is the main entry function to the program that calls other sub-routines
    to execute the program, which is, Mayer Pacakrd's Genetic Algorithm

    :return: int - Returns 0 if executed successfully, else returns 1
    """
    # ===== Step 1: Initialize the Population with a random set of C =====

    # Initialize the variables that are necessary to pull data from Google Finance
    ticker = 'TSLA'
    start_date = datetime.datetime(2015, 1, 1)
    end_date = datetime.datetime(2016, 1, 1)

    tesla_data = get_data_from_google(ticker, start_date, end_date)

    # Get all the close prices for TSLA, and convert it into a numpy array
    # "2 Improvement"
    if improvement:
        close_price = tesla_data['Close'][:-1].values / tesla_data['Close'][1:] - 1
    else:
        close_price = np.array(tesla_data['Close'].values)

    # Get the max and min from the close_price, on which we will populate
    # our range for C, or the 'population'
    max_close_price = close_price.max()
    min_close_price = close_price.min()
    # The number of individuals to return from population. In this case, a 10x5 Matrix
    population_size = (10, 5)

    # Generate the population
    population = generate_population(min_close_price, max_close_price, population_size)

    # Process the population
    processed_population = process_population(close_price, population)

    # Check if there are empty lists in the population, if so, then process_population again till
    # there are no empty lists in the population
    while True:
        empty_flag = False
        for key, value in processed_population.items():
            if len(value) == 0 or len(value) == 1:
                print('Value is empty at %d' % key)
                empty_flag = True
                break
        if empty_flag is False:
            break
        else:
            print('Reprocessing the population')
            population = generate_population(min_close_price, max_close_price, population_size)
            processed_population = process_population(close_price, population)



    # Set the number of iterations, this is for step 5
    number_of_iterations = 1
    fitness_of_individuals = dict()
    sorted_fit = list()
    for i in range(number_of_iterations + 1):
        # ===== Step 2: Calculate the Fitness of each C =====
        # We have a population of 10 individuals. We will calculate the fitness for each of these individuals

        # Set the alpha and calculate the fitness of the population
        alpha = 0.1  # The aplha is 10%
        fitness_of_individuals = calculate_fitness(processed_population, close_price, alpha)

        # ===== Step 3: Rank the population by fitness =====
        sorted_fit = sorted(fitness_of_individuals, key=fitness_of_individuals.get, reverse=True)

        if i == number_of_iterations:
            break

        # ===== Step 4: Discard some of the lower fraction individuals, and replace them =====
        # =====         by new C's obtained by applying crossover and mutations          =====

        # Discard some C's (Here, we discard the bottom 2 C's)
        del fitness_of_individuals[sorted_fit[-1]]
        del fitness_of_individuals[sorted_fit[-2]]
        del processed_population[sorted_fit[-1]]
        del processed_population[sorted_fit[-2]]

        # Get random genes from the most fittest of the population
        random_c1 = np.random.choice(population[sorted_fit[0]], 5)
        random_c2 = np.random.choice(population[sorted_fit[1]], 5)

        # Combine them into a population
        crossover_population = np.vstack([random_c1, random_c2])
        # Send them to process_population, so that we get a processed population
        # Hence, generating a crossed-over population, with mutation, since the with_mutation flag is on
        crossover_processed_population = process_population(close_price, crossover_population, with_mutation=True)

        while True:
            empty_flag = False
            for key, value in crossover_processed_population.items():
                if len(value) == 0 or len(value) == 1:
                    print('Value is empty at %d' % key)
                    empty_flag = True
                    break
            if empty_flag is False:
                break
            else:
                print('Reprocessing the population')
                random_c1 = np.random.choice(population[sorted_fit[0]], 5)
                random_c2 = np.random.choice(population[sorted_fit[1]], 5)
                crossover_population = np.vstack([random_c1, random_c2])
                crossover_processed_population = process_population(close_price, crossover_population,
                                                                    with_mutation=True)

        population_list = population.tolist()
        if sorted_fit[-1] > sorted_fit[-2]:
            del population_list[sorted_fit[-1]]
            del population_list[sorted_fit[-2]]
        else:
            del population_list[sorted_fit[-2]]
            del population_list[sorted_fit[-1]]
        population = np.array(population_list)

        # Replace by performing crossover and mutations
        # Append the crossover to the population list
        population = np.vstack([population, crossover_population])

        # Append it to the population
        processed_population[sorted_fit[-1]] = crossover_processed_population[0]
        processed_population[sorted_fit[-2]] = crossover_processed_population[1]

    # ===== Step 5: Go to Step 2, that is, calculate it's Fitness =====
    # The for-loop does this trick

    # Predict the stock price using Linear Regression
    data_x = np.array([np.mean(processed_population[0]), np.mean(processed_population[1]),
                      np.mean(processed_population[2]), np.mean(processed_population[3]),
                      np.mean(processed_population[4])])
    data_y = np.array([np.mean(processed_population[5]), np.mean(processed_population[6]),
                      np.mean(processed_population[7]), np.mean(processed_population[8]),
                      np.mean(processed_population[9])])
    regr = linear_model.LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)
    regr.fit(data_x.reshape((5,1)), data_y.reshape((5,1)))
    m = regr.coef_[0]
    b = regr.intercept_

    # Put the Data into a DataFrame and spit out the CSV file
    # "2 Improvement"
    if improvement:
        df = pd.DataFrame({'Days': [253, 254, 255, 256, 257], 'Daily Returns': m * data_y + b})
        df[['Days', 'Daily Returns']].to_csv('PredictedValues_improvement.csv', index=False)
    else:
        df = pd.DataFrame({'Days': [253, 254, 255, 256, 257], 'Value': m * data_y + b})
        df[['Days', 'Value']].to_csv('PredictedValues.csv', index=False)

    return 0

# main entry point for the program
if __name__ == '__main__':
    # Call the main function, which executes the program
    main()
    main(improvement=True)
